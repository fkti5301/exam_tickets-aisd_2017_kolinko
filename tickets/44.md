# Вопрос 44: STL: Полезные алгоритмы. Особенности применения библиотеки algorithm

В заголовочном файле algorithm определены функции для различных целей (н-р, поиска, сортировки, подсчета, манипулирования), оперирующие над диапазонами элементов. Обратите внимание, что диапазон определяется как [first, last), где last относится к элементу, следующему за последним просматриваемым или изменяемым элементом.
 Микро-алгоритмы

    swap(T &a, T &b)
    Меняет местами значения двух элементов.
    iter_swap(It p, It q)
    Меняет местами значения элементов, на которые указывают итераторы.
    max(const T &a,const T &b )
    Возвращает максимальный элемент.
    min(const T &a,const T &b )
    Возвращает минимальный элемент.
    У этих алгоритмов есть версии с тремя параметрами. Третий параметр принимает бинарный предикат, задающий упорядоченность объектов. 

Алгоритмы, не модифицирующие последовательности

    size_t count(It p, It q, const T &x)
    Возвращает, сколько раз элемент со значением x входит в последовательность, заданную итераторами p и q.
    size_t count_if(It p, It q, Pr pred)
    Возвращает, сколько раз предикат pred возвращает значение true.
    Например, count_if(p, q, divides_by(8)) вернет, сколько элементов кратно 8;

Алгоритмы типа find

    find(It p, It q, const T &x)
    Возвращает итератор на первое вхождение элемента x в последовательность, заданную итераторами p и q.
    find_if(It p, It q, Pr pred)
    Возвращает итератор на первый элемент, для которого предикат pred вернул значение true.
    find_first_of(It p, It q, Itr i, Itr j)
    Возвращает итератор на первое вхождение любого элемента из последовательности, заданной итераторами i и j, в последовательность, заданную итераторами p и q. Последовательности могут быть разных типов (например std::vector и std::list).
    min_element(It p, It q)
    Возвращает итератор на минимальный элемент последовательности.
    max_element(It p, It q)
    Возвращает итератор на максимальный элемент последовательности.
    equal(It p, It q, Itr i)
    Сравнивает две последовательности на эквивалентность. Вторая последовательность задается одним итератором, так как последовательности должны быть одинаковой длины. Если вторая короче, то undefined behaviour.
    pair <It, Itr> mismach(It p, It q, Itr i)
    Возвращает пару итераторов, указывающую на первое несовпадение последовательностей.
    F for_each(It p, It q, F func)
    Для каждого элемента последовательности применяет функтор func. Возвращаемое значение функтора после каждого применения игнорируется. Возвращает функтор func после его применения ко всем элементам.
    bool binary_search(It p, It q, const T &x)
    Возвращает true, если в упорядоченной последовательности есть элемент, значение которого равно x, false в противном случае.
    Если хотим получить итератор на элемент со значением x, то нужно использовать алгоритмы lower_bound(It p, It q, const T &x), upper_bound(It p, It q, const T &x), equal_range(It p, It q, const T &x), которые выполняют то же, что и одноименные методы для контейнера std::set. Эти алгоритмы работают за линейное время на BiDi итераторах и за логарифмическое время на RA итераторах.

Все эти алгоритмы имеют версии с параметром, принимающим бинарный предикат, задающий упорядоченность объектов.
Модифицирующие алгоритмы

    fill(It p, It q, const T &x), fill_n(It p, Size n, const T &x)
    Заполняют последовательность значениями, равными значению x.
    generate(It p, It q, F gen), generate_n(It p, Size n, F gen)
    Заполняют последовательность значениями, сгенерированными функтором gen (например, генератором случайных чисел).
    random_shuffle(It p, It q), random_shuffle(It p, It q, F &rand)
    Перемешивает элементы в случайном порядке: меняет местами каждый элемент с элементом, номер которого выбирается случайно. Третьим параметром можно задать функтор, который будет выбирать этот случайный номер. Можно передавать генератор случайных чисел, но распределение должно быть равномерным (каждая перестановка должна генерироваться с вероятностью 1/n!, а это совсем не то же самое, что каждый элемент окажется на i-м месте с вероятностью 1/n). Требует RA итераторов.
    copy(It p, It q, Itr out)
    Копирует значения элементов последовательности, заданной итераторами p и q, в последовательность, начинающуюся с итератора out.
    copy_backward(It p, It q, Itr out) Копирует элементы последовательности, заданной итераторами p и q, в последовательность, заканчивающуюся итератором out. Итераторы должны быть BiDi.
    remove_copy(It p, It q, Itr out, const T &x)
    Копирует значения элементов из последовательности, заданной итераторами p и q, в последовательность, начинающуюся с итератора out, за исключением элементов, значения которых равны значению x.
    remove_copy_if(It p, It q, Itr out, Pr pred)
    Копирует значения элементов из последовательности, заданной итераторами p и q, в последовательность, начинающуюся с итератора out, за исключением элементов, для которых предикат pred возвращает значение true.
    reverse(It p, It q)
    Переставляет элементы в обратном порядке.
    reverse_copy(It p, It q, Itr out)
    Копирует значения элементов в обратном порядке. 