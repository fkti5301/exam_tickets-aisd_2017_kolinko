**Вопрос 28:Контроль доступа к членам базовых классов. Защищённые члены.**
==============================================================================

Базовый класс - это класс, который наследуется (является родителем).
Член класса может быть:
• частным (private); это значит, что его имя можно использовать только в методах класса и в друзьях - классах(**не путать дружбу с наследованием!**), в котором он описан;

•  защищенным (protected); это значит, что его имя можно использовать только в функциях-членах и друзьях класса, в котором он описан, а также в функциях-членах и друзьях классов, являющихся производными по отношению к этому классу;

• общим (public); это значит, что его имя можно использовать в любой функции.

Члены класса, описанного со служебным словом class, являются частными по определению. Члены класса, описанного со служебным словом struct или union, являются общими по определению, например:
```cpp
class X { int x;};//x частный по определению

struct S { int s;};// s общий по определению

class B{

    public: int c;// c общий 

    private: int a;// a частный

    protected: int b; //b защищенный

};
```
**ПРИМЕР**
```cpp
class some {

    friend void f(some&);

public:

    int a_;

protected:

    int b_;

private:

    int c_;

};
 
void f(some& obj) {

    obj.a_ = 0; // OK

    obj.b_ = 0; // OK

    obj.c_ = 0; // OK

}
 
void g(some& obj) {

    obj.a_ = 0; // OK

    obj.b_ = 0; // compile time error

    obj.c_ = 0; // compile time error

}
 
class derived : public some {

    derived() {

        a_ = 0; // OK

        b_ = 0; // OK

        c_ = 0; // compile time error

    }

};
```
**ДАЛЬШЕ ВСЯ ИНФОРМАЦИЯ ДЛЯ СПРАВКИ(в билет писать не надо, а знать, наверное, надо):** 

С помощью ключевого слова friend можно обозначить так называемый дружественный класс или функцию. Такая функция (или класс) имеет доступ ко всем нестатическим полям и методам класса в котором находится через параметр-объект класса, которому она дружественна.Дружба не наследуется, не передается и не даруется:

1. Допустим, класс Bicycle - друг класса Cycle. Тогда все потомки Bicycle не будут друзьями Cycle.
2. Если класс Bicycle - друг класса Cycle, а Cycle - друг класса Auto, то Bicycle не будет другом Auto.
3. Дружба односторонняя: Bicycle - друг Cycle, но Cycle не друг Bicycle.

**ПРИМЕР ИСПОЛЬЗОВАНИЯ ДРУЖБЫ**
```cpp
class X { 

private:

    int n;
    friend void friend_function(X**** p, int i);

public:

    void member_function(int i);

};
```
```cpp
void friend_function(X* p,  int i) { p->n = i; }

// Функция не является членом класса, поэтому X:: не пишем.

// Поскольку дружественная функция не является членом класса, она не получает указатель this

// и ей необходимо явно передавать объект, с которым она будет работать. 

void X::member_function(int i) { n = i; } 

void f() {
    X obj;
    friend_function(&obj, 10); // Функции вызываются по-разному,
    obj.member_function(10);// но приводят к одному и тому же результату 
}
```
