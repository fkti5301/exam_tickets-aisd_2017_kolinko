Вопрос 28:Контроль доступа к членам базовых классов. Защищённые члены.

Базовый класс - это класс, который наследуется (является родителем).
Член класса может быть:
• частным (private); это значит, что его имя можно использовать только в методах класса и в друзьях - классах, в котором он описан;

•  защищенным (protected); это значит, что его имя можно использовать только в функциях-членах и друзьях класса, в котором он описан, а также в функциях-членах и друзьях классов, являющихся производными по отношению к этому классу;

• общим (public); это значит, что его имя можно использовать в любой функции.

Члены класса, описанного со служебным словом class, являются частными по определению. Члены класса, описанного со служебным словом struct или union, являются общими по определению, например:

class X { int x;};//x частный по определению
struct S { int s;};// s общий по определению
class B{
public: int c;// c общий 
private: int a;// a частный
protected: int b; //b защищенный
};
ПРИМЕР
class some {
  friend void f(some&);
public:
  int a_;
protected:
  int b_;
private:
  int c_;
};
 
void f(some& obj) {
  obj.a_ = 0; // OK
  obj.b_ = 0; // OK
  obj.c_ = 0; // OK
}
 
void g(some& obj) {
  obj.a_ = 0; // OK
  obj.b_ = 0; // compile time error
  obj.c_ = 0; // compile time error
}
 
class derived : public some {
  derived() {
    a_ = 0; // OK
    b_ = 0; // OK
    c_ = 0; // compile time error
  }
};

(ДАЛЬШЕ ВСЯ ИНФОРМАЦИЯ ДЛЯ СПРАВКИ(в билет писать не надо, а знать, наверное, надо): не путать дружбу с наследованием. С помощью ключевого слова friend можно обозначить так называемый дружественный класс или функцию. Такая функция (или класс) имеет доступ ко всем нестатическим полям и методам класса в котором находится через параметр-объект класса, которому она дружественна.Дружба не наследуется, не передается и не даруется:
1. Допустим, класс Bicycle - друг класса Cycle. Тогда все потомки Bicycle не будут друзьями Cycle.
2. Если класс Bicycle - друг класса Cycle, а Cycle - друг класса Auto, то Bicycle не будет другом Auto.
3. Дружба односторонняя: Bicycle - друг Cycle, но Cycle не друг Bicycle.)

class X
 { private:
    int n;
    friend void friend_function(X* p, int i);// Спецификатор доступа private не работает 
   public:
    void member_function(int i);
  };
void friend_function(X* p,  int i)
 { p->n = i; } 	// Функция не является членом класса, поэтому X:: не пишем.
		// Поскольку дружественная функция не является членом класса, она не получает указатель this
		// и ей необходимо явно передавать объект, с которым она будет работать. 
void X::member_function(int i)
 { n = i; } 
void f()
 { X obj;
   friend_function(&obj, 10); // Функции вызываются по-разному,
   obj.member_function(10);// но приводят к одному и тому же результату 
  } 	
)