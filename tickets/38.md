# Преобразования типов: динамические; неожиданные. Блокировка неявного вызова конструктора или функции преобразования типа.

Блокировка неявного вызова конструктора или функции преобразования типа: для блокировки неявного
вызова конструктора в некоем классе необходимо использовать модификатор explicit у конструктора,
неявный вызов которого необходимо заблокировать. Пример:
```
class  Line{
  public:
  int  length;
  explicit  Line(int  length){
    this­>length  =  length;  }
    Line  glueLines(Line  l1,  Linel2){ 
      return  new  Line(l1­>length  + l2­>length);
    }
};


int  main(){
Line  *line  =  glueLines(1,  5);
/*  наличие  при  конструкторе
модификатора  explicit  обеспечит
невозможность  вызова  данной  функции  в
таком  виде,  в  случае  его  отсутствия
программа  нормально  отработает  и  при
таком  вызове  функции  неявно  создаст
объекты  Line*/
}
```
**Динамическое преобразование типов:** операция *dynamic_cast* доступна только в C++ и имеет смысл
только, применительно к членам класса иерархии «полиморфных типов». Динамическое приведение
типов данных может быть использовано для безопасного приведения указателя (или ссылки) на
суперкласс, в указатель (или ссылку) на подкласс в иерархии классов. Если динамическое приведение
типов — недопустимо, так как реальный тип объекта, указывает не на тот тип подкласса, приведение
типов не выполнится.

**Динамическое приведение указателя**

При приведении указателя, в случае неудачи, dynamic_cast возвращает нулевой указатель NULL. Такое поведение обеспечивает быстрый способ определения, является ли данный объект частностью динамического типа.

Синтаксис указателя динамического приведения:

type \*subСlass = dynamic_cast< type* >( objPtr );

**Динамическое приведение ссылки**

При приведении ссылочной переменной, не возможно вернуть указатель, в случае неудачи. Поэтому будет вызвано исключение *std::bad_cast* (из заголовочного файла <typeinfo> ).


type subСlass = dynamic_cast< type & >( objReference );

Чтобы безопасно пользоваться динамическим приведением, все вызовы dynamic_cast должны быть обрамлены в блок Try/Catch.
