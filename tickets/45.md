#46. Адаптеры последовательного контейнера: стек и очередь; очередь с приоритетами.

**Адаптер** — адаптация компонентов для обеспечения различного интерфейса.

**Стек** — абстрактный тип данных, представляющий собой список элементов, организованных по
принципу LIFO (last in ­ first out) или FILO (first in ­ last out). Чаще всего принцип работы стека
сравнивают со стопкой тарелок: чтобы взять вторую сверху, нужно снять верхнюю. Зачастую стек
реализуется в виде однонаправленного списка (каждый элемент в списке содержит помимо хранимой
информации в стеке указатель на следующий элемент стека)? также часто стек располагается в
одномерном массиве с упорядоченными адресами. Такая организация стека удобна, если элемент
информации занимает в памяти фиксированное количество слов, например, 1 слово. При этом отпадает
необходимость хранения в элементе стека явного указателя на следующий элемент стека, что экономит
память.Возможны три операции со стеком: добавление элемента (иначе проталкивание, push), удаление
элемента (pop) и чтение головного элемента (peek). При проталкивании (push) добавляется новый
элемент, указывающий на элемент, бывший до этого головой. Новый элемент теперь становится
головным. При удалении элемента (pop) убирается первый, а головным становится тот, на который был
указатель у этого объекта (следующий элемент). При этом значение убранного элемента возвращается.

**Очередь** — абстрактный тип данных с дисциплиной доступа к элементам FIFO (First In — First Out).
Добавление элемента (принято обозначать словом enqueue — поставить в очередь) возможно лишь в
конец очереди, выборка — только из начала очереди (что принято называть словом dequeue — убрать из
очереди /*не путать с обозначением, принятым для двусторонней очереди: deque*/), при этом выбранный
элемент из очереди удаляется. Организовать очередь можно с помощью массива или списка. Массив:
придется заводить две переменные start и end, которые будут указывать на начало и конец очереди
соответственно, и сдвигать их при появлении удалении элементов. При выходе за “рамки” массива он
замыкается циклически. (очередь может начинаться на 5 элементе, занимать 6,7...n, 1, 2 и заканчиваться
на третьем элементе). Очевидный минус: размер очереди ограничен. Плюсы: простота работы и некая
экономия памяти. Список: динамически выделяем место под новые элементы, освобождаем из­под
ненужных, в общем, вспоминаем второй семестр проги и радуемся жизни. Организовать труднее, зато
размер очереди ограничен лишь количеством памяти компьютера. Практически во всех развитых языках
программирования реализованы очереди. В CLI для этого предусмотрен класс System.Collections.Queue с
методами Enqueue и Dequeue. В STL также присутствует класс queue<>, определенный в заголовочном
файле queue. В нём используется та же терминология (push и pop), что и в стеках.

**Очередь с приоритетом** — абстрактный тип данных, поддерживающий две обязательные
операции — добавить элемент и извлечь максимум/минимум. Предполагается, что для каждого элемента
можно вычислить его приоритет — действительное число или в общем случае элемент линейно
упорядоченного множества. Основные методы, реализуемые очередью с приоритетом, следующие:
­ insert(ключ, значение) — добавляет пару (ключ, значение) в хранилище;
­ extract_minimum() — возвращает пару (ключ, значение) с минимальным значением ключа, удаляя её из
хранилища.
При этом меньшее значение ключа соответствует более высокому приоритету. В некоторых случаях более
естественен рост ключа вместе с приоритетом. Тогда второй метод можно назвать extract_maximum().
Есть ряд реализаций в которых обе основные операции выполняются в худшем случае за время,
ограниченное O(log n), где n — количество хранимых пар. В качестве примера очереди с приоритетом
можно рассмотреть список задач работника. Когда он заканчивает одну задачу, он переходит к очередной
— самой приоритетной (ключ будет величиной, обратной приоритету) — то есть выполняет операцию
извлечения максимума. Начальник добавляет задачи в список, указывая их приоритет, то есть выполняет
операцию добавления элемента.
